import os
import sklearn as sl
from collections import Counter
try:
    import xml.etree.cElementTree as ET
except ImportError:
    import xml.etree.ElementTree as ET
import numpy as np
import math
from scipy import sparse
from sklearn import svm
from multiprocessing import Process
from sklearn.ensemble import RandomForestClassifier

import util

all_system_call_list = ['accept_socket', 'add_netjob', 'bind_socket', 'change_service_config', 'check_for_debugger', 'com_create_instance', 'com_createole_object', 
'com_get_class_object', 'connect', 'connect_socket', 'control_service', 'copy_file', 'create_directory', 'create_file', 'create_interface', 'create_key', 'create_mailslot', 
'create_mutex', 'create_namedpipe', 'create_open_file', 'create_process', 'create_process_as_user', 'create_process_nt', 'create_service', 'create_socket', 'create_thread', 
'create_thread_remote', 'create_window', 'delete_file', 'delete_key', 'delete_service', 'delete_share', 'delete_value', 'destroy_window', 'download_file', 
'download_file_to_cache', 'dump_line', 'enum_handles', 'enum_items', 'enum_keys', 'enum_modules', 'enum_processes', 'enum_services', 'enum_share', 'enum_subtypes', 
'enum_types', 'enum_values', 'enum_window', 'exit_windows', 'find_file', 'find_window', 'get_computer_name', 'get_file_attributes', 'get_host_by_addr', 'get_host_by_name', 
'get_system_directory', 'get_system_time', 'get_userinfo', 'get_username', 'get_windows_directory', 'impersonate_user', 'kill_process', 'listen_socket', 'load_dll', 
'load_driver', 'load_image', 'logon_as_user', 'message', 'move_file', 'open_file', 'open_key', 'open_mutex', 'open_process', 'open_scmanager', 'open_service', 'open_url', 
'process', 'query_value', 'read_section', 'read_value', 'recv_socket', 'remove_directory', 'revert_to_self', 'send_socket', 'set_file_attributes', 'set_file_time', 
'set_system_time', 'set_thread_context', 'set_value', 'set_windows_hook', 'show_window', 'sleep', 'start_service', 'thread', 'trimmed_bytes', 'unload_driver', 'vm_allocate', 
'vm_mapviewofsection', 'vm_protect', 'vm_read', 'vm_write', 'write_value']


def total_system_call_count_feat(tree):
    """
    arguments:
      tree is an xml.etree.ElementTree object
    returns:
      a dictionary mapping 'num_system_calls' to the number of system_calls
      made by an executable (summed over all processes)
    """
    c = Counter()
    in_all_section = False
    for el in tree.iter():
        # ignore everything outside the "all_section" element
        if el.tag == "all_section" and not in_all_section:
            in_all_section = True
        elif el.tag == "all_section" and in_all_section:
            in_all_section = False
        elif in_all_section:
            c['num_system_calls'] += 1
    
    return c['num_system_calls']

def individual_system_call_count_feat(tree):
	c = Counter()
	for system_call_name in all_system_call_list:
		c[system_call_name] =  0

	in_all_section = False
	for el in tree.iter():
		if el.tag == 'all_section' and not in_all_section:
			in_all_section = True
		elif el.tag == 'all_section' and in_all_section:
			in_all_section = False
		elif in_all_section:
			c[el.tag] += 1

	output_list = []
	for system_call_name in all_system_call_list:
		output_list.append(c[system_call_name])

	return output_list

def first_call_posit_feat(tree):
	#Note that here the output first call position is the actual position - 1
	call_count = 0
	c = Counter()
	for system_call_name in all_system_call_list:
		c[system_call_name] = -1

	in_all_section = False

	for el in tree.iter():
		if el.tag == 'all_section' and not in_all_section:
			in_all_section = True
		elif el.tag == 'all_section' and in_all_section:
			in_all_section = False
		elif in_all_section: 
			if (c[el.tag] == -1):
				c[el.tag] = call_count
			call_count += 1
	
	output_list = []
	for system_call_name in all_system_call_list:
		output_list.append(c[system_call_name])

	return output_list

def last_call_posit_feat(tree):
	call_count = 0
	c = Counter()
	for system_call_name in all_system_call_list:
		c[system_call_name] = -1

	in_all_section = False

	for el in tree.iter():
		if el.tag == 'all_section' and not in_all_section:
			in_all_section = True
		elif el.tag == 'all_section' and in_all_section:
			in_all_section = False
		elif in_all_section:
			c[el.tag] = call_count
			call_count += 1

	output_list = []
	for system_call_name in all_system_call_list:
		output_list.append(c[system_call_name])

	return output_list

all_feature_function_list = [total_system_call_count_feat, individual_system_call_count_feat, first_call_posit_feat, last_call_posit_feat]

def create_design_matrix(direc = 'train'):
	#Design matrix will have N rows. Each row containing (in order) total system call number, proportion of each kind of system call in total calls, 
	#position of the first call for each kind (scaled to 0 and 1) and postion of the last call for each kind (scale to 0 and 1). If a particular kind of system call
	#is not present in a file, then the positions of first and last call are set to 2 (indicating infinity). 
	classes = []
	ids = []
	design_matrix = [] 
	for datafile in os.listdir(direc):
		id_str, clazz = datafile.split('.')[:2]
		ids.append(id_str)
		try:
			classes.append(util.malware_classes.index(clazz))
		except ValueError:
			assert clazz == "X"
			classes.append(-1)
		xml_tree = ET.parse(os.path.join(direc, datafile))
		total_call_count = total_system_call_count_feat(xml_tree)
		individual_call_count = individual_system_call_count_feat(xml_tree)
		first_call_posit = first_call_posit_feat(xml_tree)
		last_call_posit = last_call_posit_feat(xml_tree)
		individual_call_prop = [ x/float(total_call_count) for x in individual_call_count]
		scaled_first_call_posit = []
		scaled_last_call_posit = []
		for i in range(len(first_call_posit)):
			if first_call_posit[i] == -1:
				scaled_first_call_posit.append(-1)
			else:
				scaled_first_call_posit.append(first_call_posit[i] / float(total_call_count - 1))
		for i in range(len(last_call_posit)):
			if last_call_posit[i] == -1:
				scaled_last_call_posit.append(2)
			else:
				scaled_last_call_posit.append(last_call_posit[i] / float(total_call_count - 1))

		design_matrix.append(total_call_count)

		for x in individual_call_count:
			design_matrix.append(x)

		for x in scaled_first_call_posit:
			design_matrix.append(x)

		for x in scaled_last_call_posit:
			design_matrix.append(x)

		# for x in scaled_first_call_posit:
		# 	design_matrix.append(x)

	classes = np.array(classes)

	design_matrix = np.array(design_matrix).reshape(classes.shape[0], len(design_matrix)/float(classes.shape[0]))

	print design_matrix.shape
	print classes.shape

	return design_matrix, classes, ids



def main(n_estimators = 100):
	outputfile = "mypredictions_randomforest_2.csv"

	train_design_matrix, train_classes, ids = create_design_matrix(direc = 'train')
	print 'start learning'
	malware_randforest = RandomForestClassifier(n_estimators = n_estimators, max_features = 'sqrt').fit(train_design_matrix, train_classes)
	print 'start predicting'
	predicted_classes = malware_randforest.predict(train_design_matrix)
	count = 0
	for i in range(len(predicted_classes)):
		if predicted_classes[i] == train_classes[i]:
			count += 1

	correct_ratio = count/float(len(predicted_classes))
	print 'for n_estimators = {}, the correct_ratio is {} on training data'.format(n_estimators, correct_ratio)

	del train_design_matrix

	test_design_matrix, test_classes, test_ids = create_design_matrix(direc = 'test')
	test_predicted_classes =  malware_randforest.predict(test_design_matrix)

	print "writing predictions..."
	util.write_predictions(test_predicted_classes, test_ids, outputfile)
	print "done!"

if __name__ == '__main__': main()








